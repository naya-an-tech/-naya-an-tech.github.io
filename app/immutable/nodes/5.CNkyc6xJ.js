import{s as Ce,e as s,b as o,c as a,f as S,g as d,h as c,d as j,a as u,i as pe,k as n,H as xe,l as ge,n as $e}from"../chunks/scheduler.DJEw_kJ_.js";import{S as be,i as He,c as ve,a as fe,m as ue,t as me,b as he,d as _e}from"../chunks/index.BN7hZ-gT.js";import{P as Te}from"../chunks/post.D4wPUpnM.js";import"../chunks/image_banner.DSnwlN7A.js";import{C as Le}from"../chunks/code_copy.XOKxAQKh.js";function Pe(q){let e,l,i,v=String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">우리는 파이썬으로, 모노레포를 추구하고있어. </div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">여기에는 약 <span class="token number">50</span>개의 project와 각각의 프로젝트에 api, daemon worker<span class="token punctuation">(</span>with kafka<span class="token punctuation">)</span>, batch worker 가 <span class="token number">5</span>~10개씩,  </div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">MSA 형태로 약 <span class="token number">400</span>개의 프로세스가 운영되고있는 서비스를 관리하고있어.</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">또 배포를 위한 k8s manifest, 즉, deployment yaml이 있고, </div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">각 yaml에는 최종적으로 실행시키는 command가 항상 있어.</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">이 커멘드를 활용하여,</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">역으로 해당 deployment가 어떠한 코드들과 연관되어있는지를 추적하고, </div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">모노레포에서 특정 파이썬 코드가 추가/삭제/변경됨에 따라, </div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">어떠한 deployment를 업데이트 해야하는지를 알 수 있는 도구를 만들려고 해.</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">혹은 이미 도구가 있다면 추천도 좋아.</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">어떻게 해당문제를 접근하면 좋을까?</div></div>`+"";return{c(){e=s("pre"),l=s("code"),i=new xe(!1),this.h()},l(r){e=a(r,"PRE",{});var m=S(e);l=a(m,"CODE",{class:!0});var g=S(l);i=ge(g,!1),g.forEach(j),m.forEach(j),this.h()},h(){i.a=null,u(l,"class","language-bash")},m(r,m){pe(r,e,m),n(e,l),i.m(v,l)},p:$e,d(r){r&&j(e)}}}function Me(q){let e,l,i='<a href="#">상황</a>',v,r,m="현재 모노 레포를 운영 중에 많은 코드들과 test코드로 인해 빌드 시간이 점점 길어지고있다.",g,$,W=`해당 서비스 배포 전, 관련된 코드들이 무엇인지 찾고 그 코드들의 test code만 실행하여 빌드시간을 단축시켜보려고
      한다.`,A,b,X="GPT에게 질문해보고 관련 답변으로 다시 한번 생각해보자!",D,h,Z='<a href="#gpt">GPT에게 질문</a>',O,_,ee='<a href="#">우리의 상황을 먼저 설명하자</a>',I,H,f,R,C,te='<a href="#gpt">GPT 답변</a>',V,T,ne="ChatGPT",Y,L,se=`모노레포에서 여러 프로젝트를 관리하면서, 특정 파이썬 코드의 변경에 따라 영향을 받는 서비스(또는 deployment)를
      식별하는 것은 효율적인 CI/CD 파이프라인을 구축하는 데 있어 중요한 부분입니다. 여기에는 몇 가지 접근 방법이
      있습니다:`,B,P,ae=`<li>코드 기반의 의존성 추적</li> <li>Deployment YAML과의 매핑</li> <li>변경 감지 자동화</li> <li>도구 활용</li> <li>사용자 정의 도구 개발 이러한 접근 방법을 통해, 코드 변경이 있을 때 필요한 서비스만 선택적으로 배포함으로써,
        리소스를 절약하고 배포 시간을 단축할 수 있습니다. 여러분의 시스템과 프로세스에 가장 적합한 방법을 선택하고
        필요에 따라 조정하여 적용하는 것이 중요합니다.</li>`,F,x,le='<a href="#">다시 질문하자. 코드 디펜던시를 찾는 도구 추천.</a>',J,M,ie=`<li>./projects/projectA/src/main.py 를 읽어 import문을 기반으로 연관된 모든 파일들의 목록을 찾는 도구를 개발 또는
        이미 있는 도구를 추천해줘.</li>`,K,k,oe="ChatGPT",N,y,de=`파이썬 파일에서 import 문을 기반으로 연관된 모든 파일을 찾는 작업은 의존성 분석에 해당합니다. 이를 수행할 수 있는
      몇 가지 방법과 도구를 소개합니다:`,Q,w,ce=`<li>Python 스크립트 사용</li> <li>Pydeps</li> <li>Snakefood</li> <li>Modulegraph 이 중에서 가장 적합한 도구나 방법을 선택하여 사용하면, 주어진 Python 파일과 연관된 모든 파일들의
        목록을 효과적으로 찾을 수 있을 것입니다. 만약 자세한 구현 방법이나 사용 방법에 대해 더 알고 싶다면, 추가로
        질문해 주세요.</li>`,U,E,re="위 답변을 참고해서 모노 레포에서 효율적인 테스트 코드를 실행시키도록 개선해보자!",G;return f=new Le({props:{$$slots:{default:[Pe]},$$scope:{ctx:q}}}),{c(){e=s("article"),l=s("h1"),l.innerHTML=i,v=o(),r=s("p"),r.textContent=m,g=o(),$=s("p"),$.textContent=W,A=o(),b=s("p"),b.textContent=X,D=o(),h=s("h1"),h.innerHTML=Z,O=o(),_=s("h2"),_.innerHTML=ee,I=o(),H=s("div"),ve(f.$$.fragment),R=o(),C=s("h2"),C.innerHTML=te,V=o(),T=s("p"),T.textContent=ne,Y=o(),L=s("p"),L.textContent=se,B=o(),P=s("ol"),P.innerHTML=ae,F=o(),x=s("h2"),x.innerHTML=le,J=o(),M=s("ol"),M.innerHTML=ie,K=o(),k=s("p"),k.textContent=oe,N=o(),y=s("p"),y.textContent=de,Q=o(),w=s("ol"),w.innerHTML=ce,U=o(),E=s("p"),E.textContent=re,this.h()},l(p){e=a(p,"ARTICLE",{slot:!0});var t=S(e);l=a(t,"H1",{id:!0,"data-svelte-h":!0}),d(l)!=="svelte-1f9xtts"&&(l.innerHTML=i),v=c(t),r=a(t,"P",{"data-svelte-h":!0}),d(r)!=="svelte-8r1n60"&&(r.textContent=m),g=c(t),$=a(t,"P",{"data-svelte-h":!0}),d($)!=="svelte-9p5qa7"&&($.textContent=W),A=c(t),b=a(t,"P",{"data-svelte-h":!0}),d(b)!=="svelte-kt71f7"&&(b.textContent=X),D=c(t),h=a(t,"H1",{id:!0,"data-svelte-h":!0}),d(h)!=="svelte-1goq17r"&&(h.innerHTML=Z),O=c(t),_=a(t,"H2",{id:!0,"data-svelte-h":!0}),d(_)!=="svelte-j8oizv"&&(_.innerHTML=ee),I=c(t),H=a(t,"DIV",{class:!0});var z=S(H);fe(f.$$.fragment,z),z.forEach(j),R=c(t),C=a(t,"H2",{id:!0,"data-svelte-h":!0}),d(C)!=="svelte-z8ki34"&&(C.innerHTML=te),V=c(t),T=a(t,"P",{"data-svelte-h":!0}),d(T)!=="svelte-gqtgzr"&&(T.textContent=ne),Y=c(t),L=a(t,"P",{"data-svelte-h":!0}),d(L)!=="svelte-1r5zuj0"&&(L.textContent=se),B=c(t),P=a(t,"OL",{"data-svelte-h":!0}),d(P)!=="svelte-1pp1z31"&&(P.innerHTML=ae),F=c(t),x=a(t,"H2",{id:!0,"data-svelte-h":!0}),d(x)!=="svelte-1bob0ui"&&(x.innerHTML=le),J=c(t),M=a(t,"OL",{"data-svelte-h":!0}),d(M)!=="svelte-1aaf3ap"&&(M.innerHTML=ie),K=c(t),k=a(t,"P",{"data-svelte-h":!0}),d(k)!=="svelte-gqtgzr"&&(k.textContent=oe),N=c(t),y=a(t,"P",{"data-svelte-h":!0}),d(y)!=="svelte-13wtdbk"&&(y.textContent=de),Q=c(t),w=a(t,"OL",{"data-svelte-h":!0}),d(w)!=="svelte-1ev7k2e"&&(w.innerHTML=ce),U=c(t),E=a(t,"P",{"data-svelte-h":!0}),d(E)!=="svelte-16wwqjp"&&(E.textContent=re),t.forEach(j),this.h()},h(){u(l,"id",""),u(h,"id","gpt"),u(_,"id",""),u(H,"class","code-block"),u(C,"id","gpt"),u(x,"id",""),u(e,"slot","post_content")},m(p,t){pe(p,e,t),n(e,l),n(e,v),n(e,r),n(e,g),n(e,$),n(e,A),n(e,b),n(e,D),n(e,h),n(e,O),n(e,_),n(e,I),n(e,H),ue(f,H,null),n(e,R),n(e,C),n(e,V),n(e,T),n(e,Y),n(e,L),n(e,B),n(e,P),n(e,F),n(e,x),n(e,J),n(e,M),n(e,K),n(e,k),n(e,N),n(e,y),n(e,Q),n(e,w),n(e,U),n(e,E),G=!0},p(p,t){const z={};t&1&&(z.$$scope={dirty:t,ctx:p}),f.$set(z)},i(p){G||(me(f.$$.fragment,p),G=!0)},o(p){he(f.$$.fragment,p),G=!1},d(p){p&&j(e),_e(f)}}}function ke(q){let e,l;return e=new Te({props:{$$slots:{post_content:[Me]},$$scope:{ctx:q}}}),{c(){ve(e.$$.fragment)},l(i){fe(e.$$.fragment,i)},m(i,v){ue(e,i,v),l=!0},p(i,[v]){const r={};v&1&&(r.$$scope={dirty:v,ctx:i}),e.$set(r)},i(i){l||(me(e.$$.fragment,i),l=!0)},o(i){he(e.$$.fragment,i),l=!1},d(i){_e(e,i)}}}class ze extends be{constructor(e){super(),He(this,e,null,ke,Ce,{})}}export{ze as component};
