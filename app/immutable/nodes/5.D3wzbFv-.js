import{s as _t,e as s,b as o,c as l,f as z,g as d,h as c,d as G,a as u,i as rt,k as n,H as xt,l as $t,n as gt}from"../chunks/scheduler.DJEw_kJ_.js";import{S as bt,i as Pt,c as vt,a as ft,m as ut,t as mt,b as ht,d as Ct}from"../chunks/index.BN7hZ-gT.js";import{P as yt}from"../chunks/post.CuHGFvMQ.js";import"../chunks/image_banner.B_yNV9MP.js";import{C as kt}from"../chunks/code_copy.BNBPCm3V.js";function Tt(q){let t,a,i,v=String.raw`<div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">우리는 파이썬으로, 모노레포를 추구하고있어. </div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">여기에는 약 <span class="token number">50</span>개의 project와 각각의 프로젝트에 api, daemon worker<span class="token punctuation">(</span>with kafka<span class="token punctuation">)</span>, batch worker 가 <span class="token number">5</span>~10개씩,  </div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">MSA 형태로 약 <span class="token number">400</span>개의 프로세스가 운영되고있는 서비스를 관리하고있어.</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">또 배포를 위한 k8s manifest, 즉, deployment yaml이 있고, </div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">각 yaml에는 최종적으로 실행시키는 command가 항상 있어.</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">이 커멘드를 활용하여,</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">역으로 해당 deployment가 어떠한 코드들과 연관되어있는지를 추적하고, </div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">모노레포에서 특정 파이썬 코드가 추가/삭제/변경됨에 따라, </div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">어떠한 deployment를 업데이트 해야하는지를 알 수 있는 도구를 만들려고 해.</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">혹은 이미 도구가 있다면 추천도 좋아.</div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content"></div></div><div class="code-line"><div class="code-linenotation"><span class="no-line-number"></span><span class="no-line-diff"></span></div><div class="code-content">어떻게 해당문제를 접근하면 좋을까?</div></div>`+"";return{c(){t=s("pre"),a=s("code"),i=new xt(!1),this.h()},l(p){t=l(p,"PRE",{});var m=z(t);a=l(m,"CODE",{class:!0});var $=z(a);i=$t($,!1),$.forEach(G),m.forEach(G),this.h()},h(){i.a=null,u(a,"class","language-bash")},m(p,m){rt(p,t,m),n(t,a),i.m(v,a)},p:gt,d(p){p&&G(t)}}}function Ht(q){let t,a,i="상황",v,p,m="현재 모노 레포를 운영 중에 많은 코드들과 test코드로 인해 빌드 시간이 점점 길어지고있다.",$,g,W=`해당 서비스 배포 전, 관련된 코드들이 무엇인지 찾고 그 코드들의 test code만 실행하여 빌드시간을 단축시켜보려고
      한다.`,A,b,X="GPT에게 질문해보고 관련 답변으로 다시 한번 생각해보자!",D,h,Z="GPT에게 질문",O,C,tt="우리의 상황을 먼저 설명하자",I,P,f,R,_,et="GPT 답변",V,y,nt="ChatGPT",Y,k,st=`모노레포에서 여러 프로젝트를 관리하면서, 특정 파이썬 코드의 변경에 따라 영향을 받는 서비스(또는 deployment)를
      식별하는 것은 효율적인 CI/CD 파이프라인을 구축하는 데 있어 중요한 부분입니다. 여기에는 몇 가지 접근 방법이
      있습니다:`,B,T,lt=`<li>코드 기반의 의존성 추적</li> <li>Deployment YAML과의 매핑</li> <li>변경 감지 자동화</li> <li>도구 활용</li> <li>사용자 정의 도구 개발 이러한 접근 방법을 통해, 코드 변경이 있을 때 필요한 서비스만 선택적으로 배포함으로써,
        리소스를 절약하고 배포 시간을 단축할 수 있습니다. 여러분의 시스템과 프로세스에 가장 적합한 방법을 선택하고
        필요에 따라 조정하여 적용하는 것이 중요합니다.</li>`,F,x,at="다시 질문하자. 코드 디펜던시를 찾는 도구 추천.",J,H,it=`<li>./projects/projectA/src/main.py 를 읽어 import문을 기반으로 연관된 모든 파일들의 목록을 찾는 도구를 개발 또는
        이미 있는 도구를 추천해줘.</li>`,K,w,ot="ChatGPT",N,L,dt=`파이썬 파일에서 import 문을 기반으로 연관된 모든 파일을 찾는 작업은 의존성 분석에 해당합니다. 이를 수행할 수 있는
      몇 가지 방법과 도구를 소개합니다:`,Q,M,ct=`<li>Python 스크립트 사용</li> <li>Pydeps</li> <li>Snakefood</li> <li>Modulegraph 이 중에서 가장 적합한 도구나 방법을 선택하여 사용하면, 주어진 Python 파일과 연관된 모든 파일들의
        목록을 효과적으로 찾을 수 있을 것입니다. 만약 자세한 구현 방법이나 사용 방법에 대해 더 알고 싶다면, 추가로
        질문해 주세요.</li>`,U,E,pt="위 답변을 참고해서 모노 레포에서 효율적인 테스트 코드를 실행시키도록 개선해보자!",S;return f=new kt({props:{$$slots:{default:[Tt]},$$scope:{ctx:q}}}),{c(){t=s("article"),a=s("h1"),a.textContent=i,v=o(),p=s("p"),p.textContent=m,$=o(),g=s("p"),g.textContent=W,A=o(),b=s("p"),b.textContent=X,D=o(),h=s("h1"),h.textContent=Z,O=o(),C=s("h2"),C.textContent=tt,I=o(),P=s("div"),vt(f.$$.fragment),R=o(),_=s("h2"),_.textContent=et,V=o(),y=s("p"),y.textContent=nt,Y=o(),k=s("p"),k.textContent=st,B=o(),T=s("ol"),T.innerHTML=lt,F=o(),x=s("h2"),x.textContent=at,J=o(),H=s("ol"),H.innerHTML=it,K=o(),w=s("p"),w.textContent=ot,N=o(),L=s("p"),L.textContent=dt,Q=o(),M=s("ol"),M.innerHTML=ct,U=o(),E=s("p"),E.textContent=pt,this.h()},l(r){t=l(r,"ARTICLE",{slot:!0});var e=z(t);a=l(e,"H1",{id:!0,"data-svelte-h":!0}),d(a)!=="svelte-9vvhe8"&&(a.textContent=i),v=c(e),p=l(e,"P",{"data-svelte-h":!0}),d(p)!=="svelte-8r1n60"&&(p.textContent=m),$=c(e),g=l(e,"P",{"data-svelte-h":!0}),d(g)!=="svelte-9p5qa7"&&(g.textContent=W),A=c(e),b=l(e,"P",{"data-svelte-h":!0}),d(b)!=="svelte-kt71f7"&&(b.textContent=X),D=c(e),h=l(e,"H1",{id:!0,"data-svelte-h":!0}),d(h)!=="svelte-44g3f4"&&(h.textContent=Z),O=c(e),C=l(e,"H2",{id:!0,"data-svelte-h":!0}),d(C)!=="svelte-18yv9wc"&&(C.textContent=tt),I=c(e),P=l(e,"DIV",{class:!0});var j=z(P);ft(f.$$.fragment,j),j.forEach(G),R=c(e),_=l(e,"H2",{id:!0,"data-svelte-h":!0}),d(_)!=="svelte-1rn4vqu"&&(_.textContent=et),V=c(e),y=l(e,"P",{"data-svelte-h":!0}),d(y)!=="svelte-gqtgzr"&&(y.textContent=nt),Y=c(e),k=l(e,"P",{"data-svelte-h":!0}),d(k)!=="svelte-1r5zuj0"&&(k.textContent=st),B=c(e),T=l(e,"OL",{"data-svelte-h":!0}),d(T)!=="svelte-1pp1z31"&&(T.innerHTML=lt),F=c(e),x=l(e,"H2",{id:!0,"data-svelte-h":!0}),d(x)!=="svelte-1wd9g8y"&&(x.textContent=at),J=c(e),H=l(e,"OL",{"data-svelte-h":!0}),d(H)!=="svelte-1aaf3ap"&&(H.innerHTML=it),K=c(e),w=l(e,"P",{"data-svelte-h":!0}),d(w)!=="svelte-gqtgzr"&&(w.textContent=ot),N=c(e),L=l(e,"P",{"data-svelte-h":!0}),d(L)!=="svelte-13wtdbk"&&(L.textContent=dt),Q=c(e),M=l(e,"OL",{"data-svelte-h":!0}),d(M)!=="svelte-1ev7k2e"&&(M.innerHTML=ct),U=c(e),E=l(e,"P",{"data-svelte-h":!0}),d(E)!=="svelte-16wwqjp"&&(E.textContent=pt),e.forEach(G),this.h()},h(){u(a,"id","상황"),u(h,"id","GPT에게 질문"),u(C,"id","우리의 상황을 먼저 설명하자"),u(P,"class","code-block"),u(_,"id","GPT 답변"),u(x,"id","다시 질문하자. 코드 디펜던시를 찾는 도구 추천."),u(t,"slot","post_content")},m(r,e){rt(r,t,e),n(t,a),n(t,v),n(t,p),n(t,$),n(t,g),n(t,A),n(t,b),n(t,D),n(t,h),n(t,O),n(t,C),n(t,I),n(t,P),ut(f,P,null),n(t,R),n(t,_),n(t,V),n(t,y),n(t,Y),n(t,k),n(t,B),n(t,T),n(t,F),n(t,x),n(t,J),n(t,H),n(t,K),n(t,w),n(t,N),n(t,L),n(t,Q),n(t,M),n(t,U),n(t,E),S=!0},p(r,e){const j={};e&1&&(j.$$scope={dirty:e,ctx:r}),f.$set(j)},i(r){S||(mt(f.$$.fragment,r),S=!0)},o(r){ht(f.$$.fragment,r),S=!1},d(r){r&&G(t),Ct(f)}}}function wt(q){let t,a;return t=new yt({props:{$$slots:{post_content:[Ht]},$$scope:{ctx:q}}}),{c(){vt(t.$$.fragment)},l(i){ft(t.$$.fragment,i)},m(i,v){ut(t,i,v),a=!0},p(i,[v]){const p={};v&1&&(p.$$scope={dirty:v,ctx:i}),t.$set(p)},i(i){a||(mt(t.$$.fragment,i),a=!0)},o(i){ht(t.$$.fragment,i),a=!1},d(i){Ct(t,i)}}}class jt extends bt{constructor(t){super(),Pt(this,t,null,wt,_t,{})}}export{jt as component};
